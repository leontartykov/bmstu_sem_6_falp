\chapter{Теоретические вопросы}
\section{Элементы языка: определение, синтаксис, представление в памяти}
К элементарным значениям структур данных относятся.
\begin{enumerate}
	\item \textbf{Атомы}:
	\begin{itemize}
		\item символы. Используются как идентификаторы любого объекта. Синтаксически представляются буквами, цифрами; начинаются с буквы;
		\item специальные символы --- {T, Nil}. Используются для обозначения логических констант;
		\item самоопределимые атомы --- натуральные, дробные или вещественные числа, строки, заключенные в двойные кавычки;
	\end{itemize}

	\item \textbf{Точечные пары}. Строятся при помощи бинарных узлов (узлы разделены точкой). Определяются как на листинге \ref{code:point_pairs}.
	
	\begin{lstlisting}[label=code:point_pairs, caption = Определение точечной пары.]
	Точечные пары ::= (<атом>.<атом>) |
					  (<атом>.<точечная пара>) |
			          (<точечная пара>.<атом>) | 
			          (<точечная пара>.<точечная пара>)
	\end{lstlisting}

	Синтаксическое представление отражено на листинге \ref{code:syntaxis_pairs}.
	\begin{lstlisting}[label=code:syntaxis_pairs, caption = Определение точечной пары.]
		(A.B)
	\end{lstlisting}

	\item \textbf{Список}. Строятся при помощи бинарных узлов.
	Определяются как на листинге \ref{code:lists}.
	\newpage
	\begin{lstlisting}[label=code:lists, caption = Определение списка.]
	Список ::= <пустой список> | <непустой список>,
	
	<пустой список> ::= () | Nil,
	<непустой список> ::= (<первый элемент>, <хвост>),
	<первый элемент> ::= <S-выражение>,
	<хвост> ::= <список>.		  
	\end{lstlisting}

	Синтаксически список представляется как представлено на листинге \ref{code:synataxis:lists}.
	\begin{lstlisting}[label=code:synataxis:lists, caption = Представление списка.]	
	Nil
	() 
	
	(A. (B. (C. (D. ()))))
	(A B C D) 
	(A (B C) (D (E)))
	\end{lstlisting}
\end{enumerate}

Любая непустая структура Lisp в памяти представляется списковой ячейкой, хранящей два указателя: на голову и хвост.

Универсальным разделителем между атомами является пробел.

\section{Особенности языка Lisp. Структура программы. Символ апостроф.}
Вся информация (данные и программа) в Lisp представляется в виде символьных выражений --- S-выражений. Определение S-выражения представлено на листинге \ref{code:s-expression}.

\begin{lstlisting}[label=code:s-expression, caption = Определение S-выражения.]
S-выражение ::= <атом> | <точечная пара>.
\end{lstlisting}

Символ апостроф является упрощенным способом обращения к функции quote. Пример использования функции quote и символа апостроф приведен на листинге \ref{code:quote}.
\newpage

\begin{lstlisting}[label=code:quote, caption = Пример использования функции quote и символа апостроф.]
(quote (ATOM B)) => (ATOM B)
'(ATOM B) => (ATOM B)
\end{lstlisting}

\section{Базис языка Lisp. Ядро языка.}
Базис язык Lisp образуют: атомы, структуры, базовые функции, базовые функционалы.
Базовый набор функций включает 8 встроенных:
\begin{itemize}
	\item \textbf{car} --- возвращает голову списка, являющегося значением её единственного аргумента;
	\item \textbf{cdr} --- возвращает хвост списка, являющего значением её единственного аргумента;
	\item \textbf{cons} --- имеет два аргумента (cons e1 e2). Строит новый список, первым элементом которого является значение первого аргумента e1, а хвостом - e2;
	\item \textbf{atom} --- возвращается T, если значением её единственного аргумента является атом (числовой или символьный); иначе - Nil;
	\item \textbf{eq} -- проверяет совпадение двух своих аргументов-атомов. Возвращается значение T, когда значением одного из аргументов является атом и значения аргументов равны. Иначе возвращается Nil;
	\item \textbf{quote} --- в качестве значения возвращает аргумент, не вычисляя его (используется для блокировки вычисления аргумента).
	\item \textbf{eval} --- выполняет двойное вычисление своего аргумента. Такой подход может понадобиться либо для снятия блокировки вычислений (установленного функцией quote), либо же для вычисления нового функционального вызова, сформированного в ходе первого вычисления;
	\item \textbf{cond} --- условное выражение; служит средством разветвления вычислений. Пример представлен на листинге \ref{code:cond}.

	\begin{lstlisting}[label=code:cond, caption = Вызов функции cond.]
	(cond (p_1 e_1) (p_2 e_2) ... (p_n e_n)), n >= 1
	\end{lstlisting}

	Выражения $(p_i e_i)$ являются ветвями условного выражения, а выражения-формы $p_i$ - условиями ветвей.
	
\end{itemize} 