\chapter{Теоретические вопросы}

\section{Базис Lisp}
\textit{Базис} - минимальный набор конструкций языка и структур данных, с  помощью которых можно решить любую задачу. 

Базис Lisp образуют: атомы, структуры, базовые функции, базовые функционалы.

\textit{Базисные функции} -- минимальный набор функций, которые позволяют решить любую задачу.

\section{Классификация функций}
\begin{enumerate}
	\item Чистые математические функции.
	
	Имеют фиксированное число аргументов и возвращают один результат. Сначала вычисляются все аргументы, затем к ним применяется исходная функция.
	
	\item Специальные функции (формы).
	
	\textit{Специальные функции} -- функции, у которых переменное число аргументов или они обрабатываются по-разному (один вычисляется, другой - нет).
	
	\item Псевдофункции.
	
	\textit{Псевдофункции} -- функции, которые создают "спецэффекты"; например, вывод на экран.
	
	\item Функции с вариантами значений -- выбирают какое-то одно значение.
	
	\item Функционалы.
	
	\textit{Функционалы} -- функции, которые в качестве аргументов используют функции или возвращают в качестве результата функцию. Также они называются \textit{функциями более высокого порядка}. Позволяют создавать \textit{синтаксически управляемые программы} (программы, которые сами создают какие-то функции; эти функции затем выполняются). 
	
	\item Рекурсивные.
\end{enumerate}

\section{Способы создания функций}

\begin{enumerate}
	\item lambda-выражение. Данный способ представлен с помощью формулы (\ref{eq:lambda}).
	
	\begin{equation}
		\label{eq:lambda}
		(lambda \ \lambda \text{-} \textup{список} \ \textup{форма}),
	\end{equation}

	где $\lambda$-$\textup{список}$ -- список формальных параметров, $\textup{форма}$ -- тело функции.
	
	lambda$\text{-} \textup{выражение}$ не хранится в памяти и не имеет имени. Вычисляется сразу же. Используется для повторных вычислений.
	
	Вызов lambda$\text{-} \textup{функции}$ выполняется по формуле (\ref{eq:lambda_function}).
	
	\begin{equation}
		\label{eq:lambda_function}
		(\lambda \text{-} \textup{выражение} \ \textup{последовательность форм})
	\end{equation}
	
	\item С помощью \textit{defun} по формуле (\ref{eq:defun}). 
	
	\begin{equation}
		\label{eq:defun}
		(defun \ f \ \lambda \text{-} \textup{выражение})
	\end{equation}

	Система по имени символьного атома находит его определение.
\end{enumerate}

\section{Функции Car и Cdr}
\textit{car} и \textit{cdr} являются базовыми функциями доступа к данным.

\textit{car} -- принимает на вход один аргумент и возвращает первый элемент списка.

Пример использования car и списка представлен на листинге \ref{lst:car_list}. 

\begin{lstlisting}[label=lst:car_list, caption=Использование car и списка.]
	(car '(A B C D))    ;; (A)
\end{lstlisting}

\textit{car} -- принимает на вход один аргумент и возвращает хвост списка.

Пример использования cdr и списка представлен на листинге \ref{lst:cdr_list}. 

\begin{lstlisting}[label=lst:cdr_list, caption=Использование cdr и списка.]
	(cdr '(A B C D))    ;; (B C D)
\end{lstlisting}

\section{Назначение и отличие в работе Cons и List}
\textit{cons} -- имеет два аргумента и возвращает бинарный узел. Если вторым аргументом является атом, то возвращается точечная пара; если список -- список.

\textit{list} -- имеет произвольное число аргументов и возвращает список.

Пример использования cons представлен на листинге \ref{lst:cons}.
\begin{lstlisting}[label=lst:cons, caption=Использование cons.]
	(cons 'A 'B)          ;; (A.B)
	(cons 'A '(B C D))    ;; (A B C D)
	(cons '(A B) '(C D))  ;; ((A B) C D) 
\end{lstlisting}

Пример использования list представлен на листинге \ref{lst:list}.
\begin{lstlisting}[label=lst:list, caption=Использование list.]
	(list 'A 'B)         ;; (A B)
	(list 'A '(B C) 'D)  ;; (A (B C) D)
\end{lstlisting}

функция list может быть представлена с помощью cons (листинг \ref{lst:list_cons}).

\begin{lstlisting}[label=lst:list_cons, caption=Представление list с помощью cons.]
	(defun list2 (ar1 ar2) (cons ar1 (cons ar2 ())))
	(defun list3 (ar1 ar2 ar3) (cons ar1 (cons ar2 (cons ar3 ()))))
	...
\end{lstlisting}

